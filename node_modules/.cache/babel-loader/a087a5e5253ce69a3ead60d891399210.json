{"ast":null,"code":"/*!\n * FilePondPluginFileValidateType 1.2.5\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.FilePondPluginFileValidateType = factory());\n})(this, function () {\n  'use strict';\n\n  var plugin = function plugin(_ref) {\n    var addFilter = _ref.addFilter,\n        utils = _ref.utils; // get quick reference to Type utils\n\n    var Type = utils.Type,\n        isString = utils.isString,\n        replaceInString = utils.replaceInString,\n        guesstimateMimeType = utils.guesstimateMimeType,\n        getExtensionFromFilename = utils.getExtensionFromFilename,\n        getFilenameFromURL = utils.getFilenameFromURL;\n\n    var mimeTypeMatchesWildCard = function mimeTypeMatchesWildCard(mimeType, wildcard) {\n      var mimeTypeGroup = (/^[^/]+/.exec(mimeType) || []).pop(); // image/png -> image\n\n      var wildcardGroup = wildcard.slice(0, -2); // image/* -> image\n\n      return mimeTypeGroup === wildcardGroup;\n    };\n\n    var isValidMimeType = function isValidMimeType(acceptedTypes, userInputType) {\n      return acceptedTypes.some(function (acceptedType) {\n        // accepted is wildcard mime type\n        if (/\\*$/.test(acceptedType)) {\n          return mimeTypeMatchesWildCard(userInputType, acceptedType);\n        } // is normal mime type\n\n\n        return acceptedType === userInputType;\n      });\n    };\n\n    var getItemType = function getItemType(item) {\n      // if the item is a url we guess the mime type by the extension\n      var type = '';\n\n      if (isString(item)) {\n        var filename = getFilenameFromURL(item);\n        var extension = getExtensionFromFilename(filename);\n\n        if (extension) {\n          type = guesstimateMimeType(extension);\n        }\n      } else {\n        type = item.type;\n      }\n\n      return type;\n    };\n\n    var validateFile = function validateFile(item, acceptedFileTypes, typeDetector) {\n      // no types defined, everything is allowed \\o/\n      if (acceptedFileTypes.length === 0) {\n        return true;\n      } // gets the item type\n\n\n      var type = getItemType(item); // no type detector, test now\n\n      if (!typeDetector) {\n        return isValidMimeType(acceptedFileTypes, type);\n      } // use type detector\n\n\n      return new Promise(function (resolve, reject) {\n        typeDetector(item, type).then(function (detectedType) {\n          if (isValidMimeType(acceptedFileTypes, detectedType)) {\n            resolve();\n          } else {\n            reject();\n          }\n        }).catch(reject);\n      });\n    };\n\n    var applyMimeTypeMap = function applyMimeTypeMap(map) {\n      return function (acceptedFileType) {\n        return map[acceptedFileType] === null ? false : map[acceptedFileType] || acceptedFileType;\n      };\n    }; // setup attribute mapping for accept\n\n\n    addFilter('SET_ATTRIBUTE_TO_OPTION_MAP', function (map) {\n      return Object.assign(map, {\n        accept: 'acceptedFileTypes'\n      });\n    }); // filtering if an item is allowed in hopper\n\n    addFilter('ALLOW_HOPPER_ITEM', function (file, _ref2) {\n      var query = _ref2.query; // if we are not doing file type validation exit\n\n      if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\n        return true;\n      } // we validate the file against the accepted file types\n\n\n      return validateFile(file, query('GET_ACCEPTED_FILE_TYPES'));\n    }); // called for each file that is loaded\n    // right before it is set to the item state\n    // should return a promise\n\n    addFilter('LOAD_FILE', function (file, _ref3) {\n      var query = _ref3.query;\n      return new Promise(function (resolve, reject) {\n        if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\n          resolve(file);\n          return;\n        }\n\n        var acceptedFileTypes = query('GET_ACCEPTED_FILE_TYPES'); // custom type detector method\n\n        var typeDetector = query('GET_FILE_VALIDATE_TYPE_DETECT_TYPE'); // if invalid, exit here\n\n        var validationResult = validateFile(file, acceptedFileTypes, typeDetector);\n\n        var handleRejection = function handleRejection() {\n          var acceptedFileTypesMapped = acceptedFileTypes.map(applyMimeTypeMap(query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES_MAP'))).filter(function (label) {\n            return label !== false;\n          });\n          reject({\n            status: {\n              main: query('GET_LABEL_FILE_TYPE_NOT_ALLOWED'),\n              sub: replaceInString(query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES'), {\n                allTypes: acceptedFileTypesMapped.join(', '),\n                allButLastType: acceptedFileTypesMapped.slice(0, -1).join(', '),\n                lastType: acceptedFileTypesMapped[acceptedFileTypesMapped.length - 1]\n              })\n            }\n          });\n        }; // has returned new filename immidiately\n\n\n        if (typeof validationResult === 'boolean') {\n          if (!validationResult) {\n            return handleRejection();\n          }\n\n          return resolve(file);\n        } // is promise\n\n\n        validationResult.then(function () {\n          resolve(file);\n        }).catch(handleRejection);\n      });\n    }); // expose plugin\n\n    return {\n      // default options\n      options: {\n        // Enable or disable file type validation\n        allowFileTypeValidation: [true, Type.BOOLEAN],\n        // What file types to accept\n        acceptedFileTypes: [[], Type.ARRAY],\n        // - must be comma separated\n        // - mime types: image/png, image/jpeg, image/gif\n        // - extensions: .png, .jpg, .jpeg ( not enabled yet )\n        // - wildcards: image/*\n        // label to show when a type is not allowed\n        labelFileTypeNotAllowed: ['File is of invalid type', Type.STRING],\n        // nicer label\n        fileValidateTypeLabelExpectedTypes: ['Expects {allButLastType} or {lastType}', Type.STRING],\n        // map mime types to extensions\n        fileValidateTypeLabelExpectedTypesMap: [{}, Type.OBJECT],\n        // Custom function to detect type of file\n        fileValidateTypeDetectType: [null, Type.FUNCTION]\n      }\n    };\n  }; // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n\n\n  var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n\n  if (isBrowser) {\n    document.dispatchEvent(new CustomEvent('FilePond:pluginloaded', {\n      detail: plugin\n    }));\n  }\n\n  return plugin;\n});","map":{"version":3,"sources":["/Users/aseshres/Desktop/babybook/babybook-fe/babybook-ui/node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js"],"names":["global","factory","exports","module","define","amd","self","FilePondPluginFileValidateType","plugin","_ref","addFilter","utils","Type","isString","replaceInString","guesstimateMimeType","getExtensionFromFilename","getFilenameFromURL","mimeTypeMatchesWildCard","mimeType","wildcard","mimeTypeGroup","exec","pop","wildcardGroup","slice","isValidMimeType","acceptedTypes","userInputType","some","acceptedType","test","getItemType","item","type","filename","extension","validateFile","acceptedFileTypes","typeDetector","length","Promise","resolve","reject","then","detectedType","catch","applyMimeTypeMap","map","acceptedFileType","Object","assign","accept","file","_ref2","query","_ref3","validationResult","handleRejection","acceptedFileTypesMapped","filter","label","status","main","sub","allTypes","join","allButLastType","lastType","options","allowFileTypeValidation","BOOLEAN","ARRAY","labelFileTypeNotAllowed","STRING","fileValidateTypeLabelExpectedTypes","fileValidateTypeLabelExpectedTypesMap","OBJECT","fileValidateTypeDetectType","FUNCTION","isBrowser","window","document","dispatchEvent","CustomEvent","detail"],"mappings":"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","sourcesContent":["/*!\n * FilePondPluginFileValidateType 1.2.5\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined'\n    ? (module.exports = factory())\n    : typeof define === 'function' && define.amd\n    ? define(factory)\n    : ((global = global || self),\n      (global.FilePondPluginFileValidateType = factory()));\n})(this, function() {\n  'use strict';\n\n  var plugin = function plugin(_ref) {\n    var addFilter = _ref.addFilter,\n      utils = _ref.utils;\n    // get quick reference to Type utils\n    var Type = utils.Type,\n      isString = utils.isString,\n      replaceInString = utils.replaceInString,\n      guesstimateMimeType = utils.guesstimateMimeType,\n      getExtensionFromFilename = utils.getExtensionFromFilename,\n      getFilenameFromURL = utils.getFilenameFromURL;\n\n    var mimeTypeMatchesWildCard = function mimeTypeMatchesWildCard(\n      mimeType,\n      wildcard\n    ) {\n      var mimeTypeGroup = (/^[^/]+/.exec(mimeType) || []).pop(); // image/png -> image\n      var wildcardGroup = wildcard.slice(0, -2); // image/* -> image\n      return mimeTypeGroup === wildcardGroup;\n    };\n\n    var isValidMimeType = function isValidMimeType(\n      acceptedTypes,\n      userInputType\n    ) {\n      return acceptedTypes.some(function(acceptedType) {\n        // accepted is wildcard mime type\n        if (/\\*$/.test(acceptedType)) {\n          return mimeTypeMatchesWildCard(userInputType, acceptedType);\n        }\n\n        // is normal mime type\n        return acceptedType === userInputType;\n      });\n    };\n\n    var getItemType = function getItemType(item) {\n      // if the item is a url we guess the mime type by the extension\n      var type = '';\n      if (isString(item)) {\n        var filename = getFilenameFromURL(item);\n        var extension = getExtensionFromFilename(filename);\n        if (extension) {\n          type = guesstimateMimeType(extension);\n        }\n      } else {\n        type = item.type;\n      }\n\n      return type;\n    };\n\n    var validateFile = function validateFile(\n      item,\n      acceptedFileTypes,\n      typeDetector\n    ) {\n      // no types defined, everything is allowed \\o/\n      if (acceptedFileTypes.length === 0) {\n        return true;\n      }\n\n      // gets the item type\n      var type = getItemType(item);\n\n      // no type detector, test now\n      if (!typeDetector) {\n        return isValidMimeType(acceptedFileTypes, type);\n      }\n\n      // use type detector\n      return new Promise(function(resolve, reject) {\n        typeDetector(item, type)\n          .then(function(detectedType) {\n            if (isValidMimeType(acceptedFileTypes, detectedType)) {\n              resolve();\n            } else {\n              reject();\n            }\n          })\n          .catch(reject);\n      });\n    };\n\n    var applyMimeTypeMap = function applyMimeTypeMap(map) {\n      return function(acceptedFileType) {\n        return map[acceptedFileType] === null\n          ? false\n          : map[acceptedFileType] || acceptedFileType;\n      };\n    };\n\n    // setup attribute mapping for accept\n    addFilter('SET_ATTRIBUTE_TO_OPTION_MAP', function(map) {\n      return Object.assign(map, {\n        accept: 'acceptedFileTypes'\n      });\n    });\n\n    // filtering if an item is allowed in hopper\n    addFilter('ALLOW_HOPPER_ITEM', function(file, _ref2) {\n      var query = _ref2.query;\n      // if we are not doing file type validation exit\n      if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\n        return true;\n      }\n\n      // we validate the file against the accepted file types\n      return validateFile(file, query('GET_ACCEPTED_FILE_TYPES'));\n    });\n\n    // called for each file that is loaded\n    // right before it is set to the item state\n    // should return a promise\n    addFilter('LOAD_FILE', function(file, _ref3) {\n      var query = _ref3.query;\n      return new Promise(function(resolve, reject) {\n        if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\n          resolve(file);\n          return;\n        }\n\n        var acceptedFileTypes = query('GET_ACCEPTED_FILE_TYPES');\n\n        // custom type detector method\n        var typeDetector = query('GET_FILE_VALIDATE_TYPE_DETECT_TYPE');\n\n        // if invalid, exit here\n        var validationResult = validateFile(\n          file,\n          acceptedFileTypes,\n          typeDetector\n        );\n\n        var handleRejection = function handleRejection() {\n          var acceptedFileTypesMapped = acceptedFileTypes\n            .map(\n              applyMimeTypeMap(\n                query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES_MAP')\n              )\n            )\n            .filter(function(label) {\n              return label !== false;\n            });\n\n          reject({\n            status: {\n              main: query('GET_LABEL_FILE_TYPE_NOT_ALLOWED'),\n              sub: replaceInString(\n                query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES'),\n                {\n                  allTypes: acceptedFileTypesMapped.join(', '),\n                  allButLastType: acceptedFileTypesMapped\n                    .slice(0, -1)\n                    .join(', '),\n                  lastType:\n                    acceptedFileTypesMapped[acceptedFileTypesMapped.length - 1]\n                }\n              )\n            }\n          });\n        };\n\n        // has returned new filename immidiately\n        if (typeof validationResult === 'boolean') {\n          if (!validationResult) {\n            return handleRejection();\n          }\n          return resolve(file);\n        }\n\n        // is promise\n        validationResult\n          .then(function() {\n            resolve(file);\n          })\n          .catch(handleRejection);\n      });\n    });\n\n    // expose plugin\n    return {\n      // default options\n      options: {\n        // Enable or disable file type validation\n        allowFileTypeValidation: [true, Type.BOOLEAN],\n\n        // What file types to accept\n        acceptedFileTypes: [[], Type.ARRAY],\n        // - must be comma separated\n        // - mime types: image/png, image/jpeg, image/gif\n        // - extensions: .png, .jpg, .jpeg ( not enabled yet )\n        // - wildcards: image/*\n\n        // label to show when a type is not allowed\n        labelFileTypeNotAllowed: ['File is of invalid type', Type.STRING],\n\n        // nicer label\n        fileValidateTypeLabelExpectedTypes: [\n          'Expects {allButLastType} or {lastType}',\n          Type.STRING\n        ],\n\n        // map mime types to extensions\n        fileValidateTypeLabelExpectedTypesMap: [{}, Type.OBJECT],\n\n        // Custom function to detect type of file\n        fileValidateTypeDetectType: [null, Type.FUNCTION]\n      }\n    };\n  };\n\n  // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n  var isBrowser =\n    typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  if (isBrowser) {\n    document.dispatchEvent(\n      new CustomEvent('FilePond:pluginloaded', { detail: plugin })\n    );\n  }\n\n  return plugin;\n});\n"]},"metadata":{},"sourceType":"script"}